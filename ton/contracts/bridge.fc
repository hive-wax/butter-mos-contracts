#include "imports/stdlib.fc";
#include "imports/crypto.fc";
#include "imports/params.fc";
#include "imports/message.fc";

#include "data.fc";
#include "imports/error_codes.fc";
#include "imports/utils.fc";

;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();

    (int order_nonce) = load_data();

    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case

    if (op == op::message_out) {
        int relay = in_msg_body~load_uint(8);
        int msg_type = in_msg_body~load_uint(8);
        int to_chain = in_msg_body~load_uint(64);
        slice initiator = in_msg_body~load_msg_addr();

        int remaining_bits = slice_bits(in_msg_body) - 64;
        slice target = in_msg_body~load_bits(remaining_bits);

        int gas_limit = in_msg_body~load_uint(64);

        cell payload = in_msg_body~load_ref();

        int new_order_nonce = order_nonce + 1;
        slice my_address = my_address();
        int full_order_id = get_order_id(my_address, new_order_nonce, to_chain, sender_address, target);

        emit_log_simple(LOG_MESSAGE_OUT,
            begin_cell()
                .store_ref(begin_cell()
                    .store_uint(relay, 8)
                    .store_uint(msg_type, 8)
                    .store_uint(TON_CHAIN_ID, 64)
                    .store_uint(to_chain, 64)
                    .store_uint(gas_limit, 64)
                    .store_slice(initiator)
                    .store_slice(sender_address)
                    .end_cell()
                )
                .store_ref(begin_cell().store_slice(target).end_cell())
                .store_ref(payload)
                .store_ref(begin_cell()
                    .store_uint(full_order_id, 256)
                    .store_slice(my_address)
                    .store_slice(my_address)
                    .store_uint(0, 128).end_cell()
                )
                .end_cell(), 0);

        save_data(new_order_nonce);

        return ();
    }

    if (op == op::message_in) {
        int hash = in_msg_body~load_uint(256);
        int sign_number = in_msg_body~load_uint(8);
        sign_number~dump();

        cell signs_cell = in_msg_body~load_ref();
        slice signs_slice = signs_cell.begin_parse();
        cell sign_cell = signs_slice~load_ref();
        slice sign_slice = sign_cell.begin_parse();
        int v = sign_slice~load_uint(8);
        int r = sign_slice~load_uint(256);
        int s = sign_slice~load_uint(256);

        int signed_hash = to_eth_signed_message_hash(hash);

        ;; meta
        cell meta_cell = in_msg_body~load_ref();
        slice meta_slice = meta_cell.begin_parse();

        int receipt_root = meta_slice~load_uint(256);
        int version = meta_slice~load_uint(256);
        int block_num = meta_slice~load_uint(256);
        int chain_id = meta_slice~load_uint(64);

        int expected_hash = get_meta_hash(receipt_root, version, block_num, chain_id);
        throw_unless(error::wrong_meta, expected_hash == hash);

        int expected_address = in_msg_body~load_uint(160);

        (int success, int h, int x1, int x2) = ecrecover(signed_hash, v, r, s);
        throw_unless(33, success);
        int recovered_address = pubkey_to_eth_address(h, x1);

        throw_unless(error::wrong_signature, recovered_address == expected_address);

        cell msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(sender_address)
            .store_coins(0)
            .store_msgbody_prefix_ref(
                begin_cell()
                    .store_op(op::mapo_execute)
                    .store_query_id(query_id)
                    .store_uint(1, 64) ;; from chain id
                    .store_uint(56, 64) ;; to chain id
                    .store_slice(sender_address) ;; sender address
                    .store_uint(2, 256) ;; order id
                    .store_ref(begin_cell().end_cell()) ;; message
                    .end_cell())
            .end_cell();

        send_raw_message(msg, 64);
        ;; If we've reached here, the signature is valid and the addresses match
        ;; You can perform additional actions here if needed
        return ();
    }

    throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
}

;; get methods are a means to conveniently read contract data using, for example, HTTP APIs
;; they are marked with method_id
;; note that unlike in many other smart contract VMs, get methods cannot be called by other contracts

int get_order_nonce() method_id {
    (int order_nonce)  = load_data();
    return order_nonce;
}

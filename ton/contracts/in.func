#include "imports/stdlib.fc";
#include "imports/params.fc";
#include "imports/message.fc";
#include "imports/utils.fc";
#include "imports/error_codes.fc";

#include "data.fc";

() handle_message_in(slice in_msg_body) impure {
    int hash = in_msg_body~load_uint(256);
    int sign_number = in_msg_body~load_uint(8);

    cell signs_cell = in_msg_body~load_ref();
    slice signs_slice = signs_cell.begin_parse();
    cell sign_cell = signs_slice~load_ref();
    slice sign_slice = sign_cell.begin_parse();
    int v = sign_slice~load_uint(8);
    int r = sign_slice~load_uint(256);
    int s = sign_slice~load_uint(256);

    int signed_hash = to_eth_signed_message_hash(hash);

    ;; meta
    cell meta_cell = in_msg_body~load_ref();
    slice meta_slice = meta_cell.begin_parse();

    int receipt_root = meta_slice~load_uint(256);
    int version = meta_slice~load_uint(256);
    int block_num = meta_slice~load_uint(256);
    int chain_id = meta_slice~load_uint(64);

    int expected_hash = get_meta_hash(receipt_root, version, block_num, chain_id);
    throw_unless(error::wrong_meta, expected_hash == hash);

    cell packed_cell = in_msg_body~load_ref();
    int expected_address = in_msg_body~load_uint(160);

    (int success, int h, int x1, int x2) = ecrecover(signed_hash, v, r, s);
    throw_unless(33, success);
    success~dump();

    int recovered_address = pubkey_to_eth_address(h, x1);

    ;; throw_unless(error::wrong_signature, recovered_address == expected_address);

    slice target = addr_none();

    slice packed_ds = packed_cell.begin_parse();
    int addr = packed_ds~load_uint(256);
    cell topics = packed_ds~load_ref();
    cell message = packed_ds~load_ref();

    slice message_ds = message.begin_parse();
    cell mh = message_ds~load_ref();
    cell token_mos = message_ds~load_ref();
    cell from_to = message_ds~load_ref();
    cell payload = message_ds~load_ref();

    slice mh_ds = mh.begin_parse();
    cell meta = mh_ds~load_ref();
    cell header = mh_ds~load_ref();

    slice header_ds = header.begin_parse();
    int version = header_ds~load_uint(8);
    int relay = header_ds~load_uint(8);
    int token_len = header_ds~load_uint(8);
    int mos_len = header_ds~load_uint(8);
    int from_len = header_ds~load_uint(8);
    int to_len = header_ds~load_uint(8);
    int payload_len = header_ds~load_uint(16);
    int reserved = header_ds~load_uint(64);
    int token_amount = header_ds~load_uint(128);

    slice token_mos_ds = token_mos.begin_parse();
    slice token_addr = token_mos_ds~load_bits(token_len * 8);
    slice mos_addr = token_mos_ds~load_bits(mos_len * 8);

    slice from_to_ds = from_to.begin_parse();
    slice from_addr = from_to_ds~load_bits(from_len * 8);
    slice to_addr = from_to_ds~load_bits(to_len * 8);

    if (reserved == 0) {
        cell msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(to_addr)
            .store_coins(0)
            .store_msgbody_prefix_ref(
                begin_cell()
                    .store_op(op::mapo_execute)
                    .store_query_id(0)
                    .store_uint(1, 64) ;; from chain id
                    .store_uint(56, 64) ;; to chain id
                    .store_slice(my_address()) ;; sender address
                    .store_uint(2, 256) ;; order id
                    .store_ref(payload) ;; message
                    .end_cell())
            .end_cell();

        send_raw_message(msg, 64);
        ;; If we've reached here, the signature is valid and the addresses match
        ;; You can perform additional actions here if needed
    }

    return ();
}

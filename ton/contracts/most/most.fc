#include "imports/stdlib.fc";
#include "../imports/params.fc";
#include "imports/op-codes.fc";

;; Storage
;; storage#_ order_nonce:uint256 jetton_master_address:MsgAddress = Storage;

(int, slice) load_data() impure {
    var ds = get_data().begin_parse();
    return (
        ds~load_uint(256),    ;; order_nonce
        ds~load_msg_addr()    ;; jetton_master_address
    );
}

() save_data(int order_nonce, slice jetton_master_address) impure {
    set_data(
        begin_cell()
            .store_uint(order_nonce, 256)
            .store_slice(jetton_master_address)
            .end_cell()
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    (int order_nonce, slice jetton_master_address) = load_data();

    if (op == op::mapo_execute) {
        ;; Parse cross-chain mint parameters
        slice to_address = in_msg_body~load_msg_addr();  ;; Recipient address
        int amount = in_msg_body~load_coins();          ;; Amount to mint

        ;; Prepare mint message for Jetton master
        cell mint_msg = begin_cell()
            .store_uint(op::mint, 32)           ;; op for minting
            .store_uint(query_id, 64)             ;; query_id
            .store_slice(to_address)              ;; destination address
            .store_coins(30000000)                ;; amount of TONs to send with internal_transfer
            .store_ref(                           ;; ref with internal_transfer message
                begin_cell()
                    .store_uint(op::internal_transfer, 32)
                    .store_uint(query_id, 64)
                    .store_coins(amount)          ;; amount of jettons to mint
                    .store_slice(my_address())    ;; from address (this contract)
                    .store_slice(to_address)      ;; response destination address
                    .store_coins(0)               ;; forward_ton_amount
                    .store_uint(0, 1)             ;; forward_payload in this slice, not separate cell
                    .end_cell()
            )
            .end_cell();

        ;; Send mint message to Jetton master
        var msg = begin_cell()
            .store_uint(0x18, 6)                  ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
            .store_slice(jetton_master_address)
            .store_coins(40000000)                ;; 0.04 TON for minting
            .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)  ;; minimal header info
            .store_ref(mint_msg);

        send_raw_message(msg.end_cell(), 1);  ;; mode 1 to send excess gas back

        ;; Update order nonce
        order_nonce = order_nonce + 1;
        save_data(order_nonce, jetton_master_address);
        return ();
    } else {
        throw(0xffff);
    }
}

;; Get methods
int get_order_nonce() method_id {
    (int order_nonce, _) = load_data();
    return order_nonce;
}

slice get_jetton_master_address() method_id {
    (_, slice jetton_master_address) = load_data();
    return jetton_master_address;
}

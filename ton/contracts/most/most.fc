#include "imports/stdlib.fc";
#include "../imports/params.fc";
#include "imports/op-codes.fc";

;; Storage
;; storage#_ order_nonce:uint256 jetton_master_address:MsgAddress = Storage;

(int, slice) load_data() impure {
    var ds = get_data().begin_parse();
    return (
        ds~load_uint(256),    ;; order_nonce
        ds~load_msg_addr()    ;; jetton_master_address
    );
}

() save_data(int order_nonce, slice jetton_master_address) impure {
    set_data(
        begin_cell()
            .store_uint(order_nonce, 256)
            .store_slice(jetton_master_address)
            .end_cell()
    );
}

(slice, int) decode_to_address_and_amount(slice payload) {
    payload~skip_bits(256); ;; Skip INTERCHAIN_TRANSFER
    payload~skip_bits(160); ;; Skip fromAddress

    slice to_addr = payload~load_bits(264);
    int amount = payload~load_uint(256);

    builder addr_builder = begin_cell()
        .store_uint(2, 2)
        .store_uint(0, 1)  ;; anycast
        .store_slice(to_addr);     ;; workchain + address (264 bits)

    slice full_addr = addr_builder.end_cell().begin_parse();

    return (full_addr, amount);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    (int order_nonce, slice jetton_master_address) = load_data();

    if (op == op::mapo_execute) {
        ;; Parse cross-chain mint parameters
        int from_id = in_msg_body~load_uint(64);
        int to_id = in_msg_body~load_uint(64);
        slice sender_address = in_msg_body~load_msg_addr();  ;; Recipient address
        int order_id = in_msg_body~load_uint(256);      ;; Amount to mint
        cell payload = in_msg_body~load_ref();          ;; Payload
        (slice to_user_address, int amount) = decode_to_address_and_amount(payload.begin_parse());

        ;; Prepare mint message for Jetton master
        cell mint_msg = begin_cell()
            .store_uint(op::mint, 32)           ;; op for minting
            .store_uint(query_id, 64)             ;; query_id
            .store_slice(to_user_address)              ;; destination address
            .store_coins(30000000)                ;; amount of TONs to send with internal_transfer
            .store_ref(                           ;; ref with internal_transfer message
                begin_cell()
                    .store_uint(op::internal_transfer, 32)
                    .store_uint(query_id, 64)
                    .store_coins(amount)          ;; amount of jettons to mint
                    .store_slice(my_address())    ;; from address (this contract)
                    .store_slice(sender_address)      ;; response destination address
                    .store_coins(0)               ;; forward_ton_amount
                    .store_uint(0, 1)             ;; forward_payload in this slice, not separate cell
                    .end_cell()
            )
            .end_cell();

        ;; Send mint message to Jetton master
        var msg = begin_cell()
            .store_uint(0x18, 6)                  ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
            .store_slice(jetton_master_address)
            .store_coins(40000000)                ;; 0.04 TON for minting
            .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)  ;; minimal header info
            .store_ref(mint_msg);

        send_raw_message(msg.end_cell(), 1);  ;; mode 1 to send excess gas back

        ;; Update order nonce
        order_nonce = order_nonce + 1;
        save_data(order_nonce, jetton_master_address);
        return ();
    } elseif(op == op::upgrade) {
        cell new_code = in_msg_body~load_ref();
        set_code(new_code);
        set_c3(new_code.begin_parse().bless());
    } elseif (op == op::set_jetton_master) {
        slice new_jetton_master = in_msg_body~load_msg_addr();
        save_data(order_nonce, new_jetton_master);
        return ();
    } else {
        throw(0xffff);
    }
}

;; Get methods
int get_order_nonce() method_id {
    (int order_nonce, _) = load_data();
    return order_nonce;
}

int get_order_nonce_4() method_id {
    (int order_nonce, _) = load_data();
    return order_nonce + 100;
}

slice get_jetton_master_address() method_id {
    (_, slice jetton_master_address) = load_data();
    return jetton_master_address;
}
